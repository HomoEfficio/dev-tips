# WebGL - 03 - Basic Concepts

## Primitive

### 일반적인 프로그래밍에서의 Primitive 

> **어떤 관점(또는 컨텍스트)에서 더 쪼갤 수 없는 자료형을 의미하며, 기본형 또는 원시형이라고도 한다.**

더 쪼갤 수 없다는 것 역시 상대적인 개념으로,
JVM 상에서의 int는 JVM 관점에서는 더 쪼갤 수 없지만, JVM 아래의 OS가 볼 때는 더 쪼갤 수 있으며, 
OS 관점에서의 어떤 자료형이 더 쪼갤 수 없다 하더라도, OS 아래의 H/W 관점에서는 bit 수준으로 더 쪼갤 수 있다.

### WebGL에서의 Primitive(WebGL Rendering Primitive)

> **그릴 수 있는 가장 기본적이고 원시적인 단위의 기하구조**

일상에서 기본 기하구조로 알고 있는 점, 선, 면, 입체와 다르지 않지만, WebGL에서의 입체는 Primitive로 보지 않고 면의 조합으로 보며, 하나의 면을 이루려면 3개의 버텍스, 즉 삼각형이 필요하다.

따라서 **WebGL에서의 Primitive란 크게 보면 점, 선, 삼각형**인데, **선과 삼각형은 그리는 방식에 따라 세분화된 Primitive가 있으며, 아래 그림과 같이 총 7가지의 Primitive가 존재**한다.

>![](https://camo.githubusercontent.com/157ef95b89d133244429dbfa2357b7579c1767f9/687474703a2f2f7074676d656469612e70656172736f6e636d672e636f6d2f696d616765732f63686170335f393738303332313930323932342f656c656d656e744c696e6b732f303366696731335f616c742e6a7067)
> 출처 : [http://www.informit.com/articles/article.aspx?p=2111395&seqNum=2 ](http://www.informit.com/articles/article.aspx?p=2111395&seqNum=2 )

#### 점

책에서는 포인트 스프라이트라고 표현되어있는데, **WebGL에서의 점은 수학적인 점과 달리 크기가 있다.** 점을 그리려면 셰이더의 내장 변수인 `gl_PointSize`를 이용해서 크기를 지정해줘야 한다.

크기가 있으므로 **WebGL의 점은 이미지를 입히는 텍스쳐링도 할 수 있다!!**

WebGL의 점은 삼각형에 비해 훨씬 적은 연산이 필요하므로 **대량의 입자를 표시하는 파티클(Particle) 효과에 사용**된다.

파티클 효과란 대략 이런듯.. 

[http://nullprogram.com/webgl-particles/](http://nullprogram.com/webgl-particles/)

[http://www.ibiblio.org/e-notes/webgl/models/fire.html](http://www.ibiblio.org/e-notes/webgl/models/fire.html)


## Winding Order

삼각형 하나를 그릴 때는 세 개의 버텍스가 필요하며, 삼각형을 그리는 순서(또는 방향)가 존재한다.
삼각형을 그리는 순서(또는 방향)는 두 가지로 구분된다.

- CCW(CounterClockWise) : 반시계 방향
- CW(ClockWise) : 시계 방향

![](http://learnopengl.com/img/advanced/faceculling_windingorder.png)

책에서 `두르기 순서`라고 표현하고 있는 **Winding Order란 삼각형을 그리는 순서로서 결국 CCW(반시계 방향)나 CW(시계 방향) 둘 중의 하나**이다. **WebGL의 기본 Winding Order는 CCW다.**

### Winding Order가 중요한 이유 

>**삼각형이 앞면인지 뒤면인지를 Winding Order을 통해 판별**하고, 

>**뒤면인 경우 해당 삼각형은 래스터라이징 단계 중에 제거되어 연산 부하를 줄일 수 있기 때문**이다.


## 그리기 메서드

WebGL에서의 그리기란 그리기 버퍼(Frame Buffer)를 갱신하는 것을 의미하며, 그리기 메서드는 3가지가 있다.

### gl.clear()

gl.clearColor()로 지정한 색깔로 모든 픽셀을 채운다.

### gl.drawArrays(mode, offset, count)


>mode : 그리기 모드(또는 Primitive : gl.POINTS, gl.LINES, ...)

>offset : 버텍스 버퍼 상에서 그리기에 사용할 버텍스의 시작 인덱스

>count : 버텍스의 개수


인덱스 버퍼를 사용하지 않고 오로지 버텍스 버퍼만을 사용해서 버텍스 버퍼에 있는 순서대로 그린다.

책 138페이지 그림 참조

- 장점
    - 인덱스 버퍼를 사용하지 않고 버텍스 버퍼에서 바로 버텍스 정보를 뽑으므로 데이터 용량을 적게 차지한다. 
- 단점
    - 버텍스가 여러 삼각형에서 공유되는 경우 실제 필요한 버텍스보다 더 많은 버텍스를 사용하게 된다.
    - 버텍스가 여러 삼각형에서 공유되어도 모두 다른 버텍스로 인식하여 캐쉬에 의한 성능 향상 효과를 누릴 수 없다.

결론적으로 연접하지 않는, 즉 버텍스가 공유되지 않는 삼각형이 많을 때 유리하다.

### gl.drawElements(mode, count, type, offset)

>mode : 그리기 모드(또는 Primitive : gl.POINTS, gl.LINES, ...)

>count : 인덱스의 개수

>type : 인덱스의 데이터 타입(기본은 gl.UNSINGED_BYTE)

>offset : 인덱스 버퍼 상에서 그리기에 사용할 인덱스의 시작 인덱스

인덱스 버퍼와 버텍스 버퍼를 함께 사용해서 그린다.

책 139페이지 그림 참조

- 장점
    - 버텍스가 여러 삼각형에서 공유되는 경우 하나의 버텍스를 인덱스 번호만 다르게 해서 재사용 할 수 있다.
    - 버텍스를 재사용 할 수 있으므로 데이터 용량을 절약할 수 있고, 캐쉬에 의한 성능 향상 효과를 누릴 수 있다.
- 단점
    - 인덱스 버퍼를 통해서 버텍스 정보를 뽑으므로 인덱스가 효율적으로 구성되지 않을 경우 성능이 낮다.
    
결론적으로 연접하는 삼각형이 많을 떄 유리하며, 실무에서는 삼각형이 연접하여 메쉬를 구성하는 경우가 대부분이므로 가장 많이 사용된다.

## 겹치기 삼각형

실무적으로는 사람이 하지 않고 3d Max같은 도구가 해주므로 걍 션하게 Skip!!   

## ArrayBuffer

> **WebGL에서의 ArrayBuffer란 일반적인 프로그래밍에서의 ByteArray를 말한다.**
> ByteArray란 각 원소가 1byte로 되어있고, 각 원소가 메모리 상에 연속적으로 존재하는 배열을 말한다.

### ArrayBuffer를 왜 쓰는가

**JavaScript의 `Array`는 이름과는 달리 메모리 상에 연속적으로 존재하는 자료구조가 아니고, 일반적인 프로그래밍에서 말하는 LinkedList에 해당한다.**

**GPU는 LinkedList가 아니라 Array만** 받을 수 있다. 따라서 **WebGL API를 통해 GPU에 배열을 넘기려면 JavaScript에도 일반적인 프로그래밍에서 말하는 진정한 Array에 해당하는 자료구조가 필요**하다. **JavaScript에서 진정한 Array에 해당하는 자료구조가 바로 ArrayBuffer다.**

GPU와의 관련성을 강조하기 위해 Buffer라는 이름을 사용하는 듯

## TypedArray

> **TypeArray는 ArrayBuffer의 View이다.**

ArrayBuffer는 자료구조를 생성하지만, ArrayBuffer를 통해서는 그 자료구조 내의 데이터에 접근할 수 없다.
ArrayBuffer는 MVC 패턴의 Model에 해당하고 Model에 직접 접근할 수 없고, TypedArray라는 View를 생성해서 그 View를 통해 접근해야 한다.

MVC에서 Model은 여러가지의 View에 의해 사용될 수 있다. 마찬가지로 하나의 ArrayBuffer는 여러가지의 TypedArray에 의해 사용될 수 있다.

쉽게 말해 ArrayBuffer는 배열의 크기를 지정하는데만, 즉 메모리 상에서 연속된 공간을 확보하는데만 사용될 뿐이고, 값을 set/get 하려면 TypedArray를 사용해야 하고, 데이터 타입을 지정하는 것도 TypedArray를 사용해야 한다.

GPU는 전달받은 모든 데이터를 Float로 처리하므로, TypedArray로 지정하는 데이터 타입은 데이터를 보내는 입장에서의 최적화라는 의미만 있다. 

```
var ab = new ArrayBuffer(8);
ab; // ArrayBuffer {}
ab[0]; // undefined
ab[9]; // undedined
console.dir(ab); // byteLength라는 속성밖에 없다.

var ta = new Float32Array(ab);
ta; // [0, 0]
ta[0]; // 0
ta[0] = 3;
ta[0]; // 3
console.dir(ta); // 여러가지 속성 있다.
```

## 인덱스 버퍼(Index Buffer)

>인덱스는 각 버텍스에 매기는 일종의 일련번호를 말한다. 
>인덱스 버퍼는 여러 버텍스의 인덱스 정보를 포함하는 배열을 말한다.

### 인덱스 버퍼를 왜 쓰는가

아래 그림에서 왼쪽은 인덱스를 사용하지 않는 방식, 오른쪽은 인덱스를 사용하는 방식이다.

![](http://www.opengl-tutorial.org/wp-content/uploads/2011/05/indexing1.png)

먼저 눈에 띄는 차이점은 사용하는 버텍스의 개수이다. 
인덱스를 사용하지 않는 왼쪽 그림에서 v2와 v3은 모두 (1, 2)라는 물리적으로 동일한 버텍스를 가리키지만 메모리 상에서는 각각 하나의 버텍스로 존재한다. 결과적으로 **물리적으로는 하나인 버텍스를 메모리에서는 두 개의 버텍스로 사용하므로 낭비가 발생**한다.
반면에 오른쪽은 물리적으로 하나의 버텍스인 (1, 2)에 하나의 인덱스(2)를 부여하고 두 개의 삼각형을 그릴 때 v2 **버텍스를 재사용하므로 메모리를 절약**할 수 있다.

또다른 차이점은 왼쪽은 삼각형을 그릴 때 **버텍스 버퍼 내에서의 버텍스의 순서에 의존**하지만, 오른쪽은 버텍스의 순서가 아니라 **인덱스의 순서에 따라 삼각형을 그린다**는 점이다.
왼쪽 방식에서는 버텍스 버퍼 내에서 버텍스의 순서에 따라 **언제나 메모리에서 버텍스를 읽어와야** 하지만, 오른쪽 방식에서는 **인덱스를 이용해서 메모리 대신 캐쉬에서 버텍스를 읽어올 수도 있으므로 성능 향상 효과**를 얻을 수 있다.

정리하면 인덱스 버퍼를 사용하는 이유는 다음과 같다.

>- 버텍스의 재사용을 통한 메모리 절약
>- 캐쉬를 활용한 성능 향상 효과
>- 버텍스의 순서에 의존 불필요

## 변환 후 버텍스 캐쉬(Post-Transform Vertex Cache)

> 버텍스 셰이더에 의해 **변환(이동, 회전, 크기)되고난 후의 버텍스 위치를 저장**해두는 GPU 내의 캐쉬

![](http://i.stack.imgur.com/2LVa3.png)

이 육각형을 화면 상에서 반시계 방향으로 23도 회전시키고, 좌측으로 50px 옮기는 변환을 한다고 가정하고, 이 변환을 CPU가 아니라 GPU에서, 즉, 버텍스 셰이더에서 수행한다고 가정하자.

그럼 버텍스 셰이더는 각 버텍스마다 23도 회전, 50px 이동 계산을 수행할 것이다. 아무런 캐쉬가 없다면 정가운데에서 **6개의 삼각형에 의해 공유되고 있는 점0의 경우는 똑같은 계산을 6회나 수행**할 것이다.

**캐쉬가 있다면 똑같은 계산을 되풀이 할 필요없이 캐쉬에 이미 저장되어 있는 계산 결과를 불러다 쓰기만 하면 계산량을 줄이고 결국 성능 향상 효과**를 얻을 수 있다.

이 캐쉬가 바로 **변환 후 버텍스 캐쉬**다. 변환 후 버텍스 캐쉬의 효율을 높이려면 하나의 버텍스를 계산하는 위치가 밀집되어 있어야 하는데, 이 **밀집도를 좌우하는 것이 인덱스 버퍼의 구성**이다. 따라서 인덱스 버퍼를 잘 구성해야 변환 후 버텍스 캐쉬에 의한 성능 향상 효과를 극대화 할 수 있다.

참고로 버텍스 계산이 여러 개의 코어에서 나누어져 실행될텐데 그럼에도 불구하고 각 코어가 캐쉬에 값을 쓰고, 캐쉬에서 값을 읽을 수 있다는 것으로 미루어 볼 때 **변환 후 버텍스 캐쉬는 아래와 같이 코어 밖에 있을 것으로 추정**.

![](http://i.imgur.com/LcgRgzn.png)

GPU에 있는 변환 후 버텍스 캐쉬는 FIFO(First In, First Out) 방식으로 되어 있고 용량이 작다(라고 책에는 되어 있으나 최신 추세는 그렇게 작지는 않은 모양).

책에는 `후변환 버텍스 캐쉬`로 번역되어 있지만 의미상 `변환 후 버텍스 캐쉬`로 번역하는 것이 맞음.

## 변환 전 버텍스 캐쉬(Pre-Transform Vertex Cache)

> 변환 후 버텍스 캐쉬에서 해당 버텍스를 찾을 수 없을 때는, 버퍼에서 연속적인 큰 용량의 데이터를 가져오는데 이 데이터를 담아두는 곳이 변환 전 버텍스 캐쉬다.

버퍼에서 하나하나 값을 가져오면 IO 비용이 많이 발생하므로 연속적이고 큰 블럭의 데이터를 한 번에 가져온다. 
버텍스 셰이더에서 버텍스 계산을 할 때 **필요한 버텍스들이 이 캐쉬에 모두 들어있다면 메모리에 다시 접근할 필요가 없지만, 필요한 버텍스가 이 캐쉬에 없다면 연속적이고 큰 블럭의 데이터를 다시 가져와야 한다.** 
이런 비효율이 발생하지 않게 하려면 버텍스를 인덱스 배열의 순서에 맞게 버텍스 버퍼에 넣는 것이 좋다.

## 셰이더 변수의 종류

셰이더에서 사용할 수 있는 변수의 종류(데이터 타입이 아닌 그냥 구분)는 세 가지가 있다.

### attribute

> `gl.vertexAttribPointer()`에 의해 전달받은 데이터(주로 위치, 컬러, 노멀 벡터 등)를 넘겨받는 변수
> - 코어 별로 쪼개진 데이터가 각 코어 별 버텍스 셰이더 내의 attribute 변수로 넘어온다.
> - 버텍스 셰이더에서만 사용되며 읽기 전용 

``` glsl
// aVertexPosition이라는 attribute 변수에 vec3 타입의 데이터(버텍스 데이터)가 넘어온다.
attribue vec3 aVertexPosition;
```

### uniform

> `gl.unformMatrix#fv()` 또는 `gl.uniform#f()`를 통해 전달받은 상수 데이터(주로 변환 계산에 사용되는 행렬)를 넘겨받는 변수
> - 코어 별 모든 버텍스 셰이더 또는 프래그먼트 셰이더에 동일한 상수값으로 전달된다.
> - 버텍스 셰이더, 프래그먼트 셰이더 모두에서 사용되며 읽기 전용

``` glsl
// uMVMatrix라는 uniform 변수에 mat4 타입의 데이터(모델뷰 변환 매트릭스)가 넘어온다.
uniform mat4 uMVMatrix;
```

### varying

> 버텍스 셰이더에서 계산한 결과 값을 프래그먼트 셰이더에 넘겨줄 때 사용하는 변수
> - 버텍스 셰이더와 프래그먼트 셰이더에서 동일한 변수명과 동일한 타입으로 선언되어야 전달이 가능하다.
> - 버텍스 셰이더에서는 정점 단위 계산을 하지만, 프래그먼트 셰이더에서는 프래그먼트(픽셀) 단위의 값이 필요하다. 따라서 버텍스가 아닌 위치에서는 Primitive 조립, 래스터라이징을 거치면서 보간(interpolation)된 값이 넘어온다.  
> - 버텍스 셰이더에서는 쓰기 가능, 프래그먼트 셰이더에서는 읽기 전용

``` glsl
<script type='x-shader/x-vertex'>
// v_color라는 varying 변수에는 vec4 타입의 데이터를 담을 수 있다.
varying vec4 v_color;
...
void main() {  
    gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
 
    // 버텍스 위치값을 이용해서 색상값 계산
    v_color = gl_Position * 0.5 + 0.5;
}
</script>

<script type='x-shader/x-fragment'>
precision mediump float;

// 버텍스 셰이더에 선언된 변수명과 타입이 동일해야 한다. 
varying vec4 v_color;
 
void main() {
    // 버텍스 셰이더에서 버텍스 단위로 계산된 값이 
    // 프리미티브 조립과 래스터라이징 단계를 거치면서 보간된 값으로 넘어온다. 
    gl_FragColor = v_color;
}
</script>
```

## 상수의 사용

상수의 사용은 두 가지 방법이 있다.

1. `gl.disableVertexAttribArray()`와 `gl.vertexAttrib#f()`를 이용해서 attribute 변수를 활용하는 방법
2. `gl.uniform#f()` 또는 `gl.uniformMatrix#fv()`를 이용해서 uniform 변수를 활용하는 방법

**실무에서는 2번 방식**을 쓴다.
